Dify v1.9.0のリリースノート( https://github.com/langgenius/dify/releases/tag/1.9.0 )を翻訳したものです。

### 1.9.0 – 知識のオーケストレーションとワークフローの強化

#### 🚀 イントロダクション

Dify 1.9.0では、2つの主要な新機能を導入します：ナレッジパイプラインとキューベースのグラフエンジンです。
ナレッジパイプラインは、知識の取り込みと処理のためのモジュール化され拡張可能なワークフローを提供します。一方、キューベースのグラフエンジンは、ワークフローの実行をより堅牢かつ制御可能にします。これらの機能により、AIアプリケーションの構築とデバッグがよりスムーズに行えるようになると確信しており、皆様のご利用体験を通じて継続的な改善を図ってまいります。

### 📚ナレッジパイプライン

#### ✨イントロダクション

知識パイプライン向けの全く新しいオーケストレーションインターフェースにより、文書処理の設計と実行方法を再構築する根本的なアーキテクチャのアップグレードを導入します。これにより、よりモジュール化され柔軟なワークフローが実現され、ユーザーはパイプラインの各段階をオーケストレーションできるようになります。マーケットプレイスで入手可能な多様な強力なプラグインにより強化され、ユーザーは様々なデータソースや処理ツールを柔軟に統合できます。このアーキテクチャにより、スケーラビリティ、適応性、精度に対する企業の高まる要求を満たす、高度にカスタマイズされたドメイン特化型RAGソリューションの構築が可能となります。

#### ❓なぜそれが必要なのか？

これまで、DifyのRAGユーザーは実世界での導入において、不正確な知識検索や情報損失から、データ統合や拡張性の制限に至るまで、持続的な課題に直面してきました。主な課題点としては以下が挙げられます：

- 🔗 データソースの統合が制限されている 
- 🖼️ 表や画像などの重要な要素が欠落している 
- ✂️ チャンク化の結果が最適ではない

これらすべてが回答品質の低下を招き、モデルの全体的なパフォーマンスを阻害します。

これに対応するため、DifyにおけるRAGをオープンでモジュール式のアーキテクチャとして再構築しました。これにより、開発者、インテグレーター、ドメインエキスパートは、データ取り込みからチャンク保存・検索に至るまで、特定の要件に合わせた文書処理パイプラインを構築できるようになります。

#### 🛠️ コア機能

##### 🧩 ナレッジパイプラインアーキテクチャ

ナレッジパイプラインは、文書取り込みに特化した視覚的なノードベースのオーケストレーションシステムです。複雑な文書処理を自動化するカスタマイズ可能な方法を提供し、きめ細かい変換を可能にするとともに、生のコンテンツと構造化され検索可能な知識を結びつけます。開発者はパズルを組み立てるように段階的にワークフローを構築できるため、文書処理の監視や調整が容易になります。

- ⚡ 公式テンプレートですぐに始められます
- 🔄 DSL 経由でインポート/エクスポートすることでパイプラインをカスタマイズおよび共有でき、再利用性とコラボレーションが容易になります

##### 🔌 カスタマイズ可能なデータソースとツール

各ナレッジベースは複数のデータソースをサポートします。プラグインベースの取り込みフレームワークを通じて、ローカルファイル、オンライン文書、クラウドドライブ、ウェブクローラーをシームレスに統合できます。開発者は新しいデータソースプラグインでエコシステムを拡張できる一方、マーケットプレイスのプロセッサーが数式、スプレッドシート、画像解析などの特殊なユースケースを処理し、正確な取り込みと構造化された表現を保証します。

##### 🧾 新しいチャンキング手法

新しいQ&Aプロセッサプラグインは、一般モードと親子モードに加え、Q&A構造もサポートします。これにより、検索精度とコンテキストの完全性のバランスを保ちながら、より多くのユースケースに対応できるようになります。

##### 🖼️ 画像の抽出と検索

複数の形式のドキュメントから画像を抽出し、ナレッジ ベースに URL として保存し、テキストと画像の混合出力を有効にして、LLM によって生成された回答を改善します。

##### 🧪 テスト実行とデバッグのサポート

パイプラインを公開する前に、次の操作を実行できます。

- ▶️ 単一のステップまたはノードを個別に実行する
- 🔍 中間変数を詳細に検査する 
- 👀 変数インスペクターで文字列変数を Markdown としてプレビューする

これにより、あらゆる段階で安全な反復とデバッグが可能になります。

##### 🔄 レガシーナレッジベースからのワンクリック移行

既存のナレッジ ベースを 1 回のアクションで Knowledge Pipeline アーキテクチャにシームレスに変換し、スムーズな移行と下位互換性を確保します。

#### 🌟 なぜそれが重要なのか

ナレッジパイプラインは、ナレッジマネジメントをより透明性が高く、デバッグ可能で、拡張性の高いものにします。これは最終形ではなく、マルチモーダル検索、人間が関与する協働、企業レベルのデータガバナンスといった将来の機能強化のための基盤です。皆様がこれをどのように活用し、フィードバックを共有されるか楽しみにしています。

### ⚙️ キュー駆動グラフエンジン

#### ❓ なぜ必要なのか？

これまで、並列分岐を含むワークフローを設計すると、次のような問題が発生することが多かった。
- 🌀 分岐状態の管理とエラーの再現が困難 
- ❌ デバッグ情報が不十分
- 🧱 柔軟性に欠ける固定的な実行ロジック

これらの問題により、複雑なワークフローの使い勝手が低下していました。これを解決するために、キュースケジューリングを中心とした実行エンジンを再設計し、並列タスクの管理を改善しました。

#### 🛠️ コア機能

##### 📋 キュースケジューリングモデル
すべてのタスクは統合されたキューに入り、スケジューラが依存関係と順序を管理します。これにより、並列実行におけるエラーが削減され、トポロジがより直感的になります。

##### 🎯 柔軟な実行開始ポイント
実行はどのノードからでも開始でき、部分実行、再開、サブグラフ呼び出しをサポートします。

##### 🌊 ストリーム処理コンポーネント
新しい **ResponseCoordinator** は、トークンごとの LLM 生成や長時間実行タスクからのステージングされた結果など、複数のノードからのストリーミング出力を処理します。

##### 🕹️ コマンドメカニズム
**CommandProcessor** を使用すると、実行中にワークフローを一時停止、再開、または終了できるため、外部制御が可能になります。

##### 🧩 グラフエンジンレイヤー
コアコードを変更することなくエンジンの機能を拡張できる新しいプラグインレイヤー。状態の監視、コマンドの送信、カスタム監視のサポートが可能です。

#### Quickstart

1. **前提条件**
    - Dify バージョン: 1.9.0 以上 
2. **有効にする方法**
   - デフォルトで有効になっており、追加の設定は必要ありません。 
   - デバッグモード: DebugLoggingLayer を有効にするには、DEBUG=true を設定します。
- 実行制限：
	- `WORKFLOW_MAX_EXECUTION_STEPS=500`
	- `WORKFLOW_MAX_EXECUTION_TIME=1200`
	- `WORKFLOW_CALL_MAX_DEPTH=10`
- ワーカー構成（オプション）:
	-  `WORKFLOW_MIN_WORKERS=1`
	- `WORKFLOW_MAX_WORKERS=10`
	- `WORKFLOW_SCALE_UP_THRESHOLD=3`
	- `WORKFLOW_SCALE_DOWN_IDLE_TIME=30`
- すべてのワークフローに適用されます。

#### より制御可能な並列分岐

```
実行フロー:

開始 ─→ 統合タスクキュー ─→ ワーカープールのスケジューリング
                ├─→ ブランチ1の実行
                └─→ ブランチ2の実行
                        ↓
                    アグリゲーター
                        ↓
                       終了

改善点:
1. すべてのタスクは、Dispatcher によって管理される単一のキューに入ります。 
2. ワーカープールは負荷に応じて自動スケールします。 
3. ResponseCoordinator はストリーミング出力を管理し、正しい順序を確保します。
```

#### 例: コマンドメカニズム

```
from core.workflow.graph_engine.manager import GraphEngineManager

# 停止コマンドを送信する
GraphEngineManager.send_stop_command(
    task_id="workflow_task_123",
    reason="Emergency stop: resource limit exceeded"
)
```

Note : 一時停止/再開機能は将来のバージョンでサポートされる予定です。

#### 例: GraphEngineLayer

[GraphEngineLayer 例](https://github.com/langgenius/dify/blob/feat/queue-based-graph-engine/api/core/workflow/graph_engine/layers/debug_logging.py)

### よくある質問

1. **このリリースはパフォーマンスに重点を置いていますか?**
   いいえ。並列分岐の安定性、明確さ、正確性に重点が置かれており、パフォーマンスの向上は副次的なメリットです。
2. **どのようなイベントをサブスクライブできますか?**
	 グラフレベル: GraphRunStartedEvent、GraphRunSucceededEvent、GraphRunFailedEvent、GraphRunAbortedEvent 
	 ノードレベル: NodeRunStartedEvent、NodeRunSucceededEvent、NodeRunFailedEvent、NodeRunRetryEvent
	 コンテナノード: IterationRunStartedEvent、IterationRunNextEvent、IterationRunSucceededEvent、LoopRunStartedEvent、LoopRunNextEvent、LoopRunSucceededEvent 
	 ストリーミング出力: NodeRunStreamChunkEvent
3. **ワークフロー実行をデバッグするにはどうすればいいですか?** 
   - 詳細なログを表示するには、DEBUG=true を有効にしてください。
   - イベントを記録するには、DebugLoggingLayer を使用してください。
   - GraphEngineLayer を介してカスタム監視を追加します。

### 今後の計画
このリリースはまだ始まりに過ぎません。今後の改善点は以下の通りです。：

- **デバッグ ツール**: 実行状態と変数をリアルタイムで表示するビジュアル インターフェイス。
- **インテリジェントなスケジューリング**：履歴データを使用してスケジューリング戦略を最適化します。 
- **より包括的なコマンドサポート**：一時停止/再開、ブレークポイントデバッグ機能を追加します。
- **人間が関与する**: 実行中に人間の介入をサポートします。
- **マルチモーダル埋め込み**: テキスト以外の豊富なコンテンツ タイプをサポートします。

エンジンをより実用的なものにするために、皆様のフィードバックとご経験をお待ちしております。

### アップグレードガイド

> **重要**
> アップグレード後、既存のデータソース認証情報を変換するために、以下の移行手順を実行する必要があります。この手順は、新バージョンとの互換性を確保するために必要です。

```
uv run flask transform-datasource-credentials
```

#### Docker Compose デプロイメント

1. カスタマイズした docker-compose YAML ファイルをバックアップします (オプション)

```
cd docker
cp docker-compose.yaml docker-compose.yaml.$(date +%s).bak
```

2. メインブランチから最新のコードを取得する

```
git checkout 1.9.0
git pull origin 1.9.0
```

3. サービスを停止します。dockerディレクトリで実行してください。

```
docker compose down
```

4. データのバックアップ

```
tar -cvf volumes-$(date +%s).tgz volumes
```

5. アップグレードサービス

```
docker compose up -d
```

6. コンテナの起動後にデータを移行する

```
docker exec -it docker-api-1 uv run flask transform-datasource-credentials
```

#### ソースコードの展開

1. API サーバー、ワーカー、および Web フロントエンド サーバーを停止します。
2. リリース ブランチから最新のコードを取得します。
```
git checkout 1.9.0
```

3. Python の依存関係を更新します。
```
cd api
uv sync
```
4. 次に、移行スクリプトを実行します。
```
uv run flask db upgrade
uv run flask transform-datasource-credentials
```

> **重要** 
> 現在バージョン v2.0.0-beta.1 または v2.0.0-beta.2 をご利用の場合は、以下の移行スクリプトを実行してアップグレードする必要があります。
> **[警告] これは破壊的な操作であり、データが失われます。**
> この移行スクリプトにより、次のデータが完全に削除されます。
> - 既存のすべてのナレッジパイプライン
> - 関連するすべてのデータセット認証情報
> 続行する前に、必要な情報がすべてバックアップされていることを確認してください。

```
# Dify環境の場合:`v2.0.0-beta.1` または `v2.0.0-beta.2`
uv run flask db downgrade cf7c38a32b2d  

# Dify環境：`v1.9.0`
uv run flask db upgrade
uv run flask transform-datasource-credentials
```

5. 最後に、API サーバー、ワーカー、Web フロントエンド サーバーを再度実行します。

※ What's Changedは割愛